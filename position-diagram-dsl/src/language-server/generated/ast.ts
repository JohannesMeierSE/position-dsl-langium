/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type INTERSECTION = '-|' | '|-';

export type POS_ANCHOR = 'center' | 'east' | 'north' | 'north_east' | 'north_west' | 'south' | 'south_east' | 'south_west' | 'west';

export type ROUTING = '--' | '-|' | '|-';

export interface Edge extends AstNode {
    readonly $container: Model;
    readonly $type: 'Edge';
    description?: string
    from: Position
    fromText?: TextElement
    name: string
    parts: Array<EdgePart>
    toText?: TextElement
}

export const Edge = 'Edge';

export function isEdge(item: unknown): item is Edge {
    return reflection.isInstance(item, Edge);
}

export interface EdgePart extends AstNode {
    readonly $container: Edge;
    readonly $type: 'EdgePart';
    pos: Position
    routing: ROUTING
}

export const EdgePart = 'EdgePart';

export function isEdgePart(item: unknown): item is EdgePart {
    return reflection.isInstance(item, EdgePart);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    edges: Array<Edge>
    nodes: Array<Node>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Node extends AstNode {
    readonly $container: Model;
    readonly $type: 'Node';
    anchor?: POS_ANCHOR
    description?: string
    name: string
    position?: Position
}

export const Node = 'Node';

export function isNode(item: unknown): item is Node {
    return reflection.isInstance(item, Node);
}

export interface Position extends AstNode {
    readonly $container: Edge | EdgePart | Node | PositionIntersection | TextElement;
    readonly $type: 'Position' | 'PositionAlongEdge' | 'PositionAnchor' | 'PositionIntersection' | 'PositionNormal';
    xshift: string
    yshift: string
}

export const Position = 'Position';

export function isPosition(item: unknown): item is Position {
    return reflection.isInstance(item, Position);
}

export interface TextElement extends AstNode {
    readonly $container: Edge;
    readonly $type: 'TextElement';
    anchor?: POS_ANCHOR
    name?: string
    pos: Position
    text?: string
}

export const TextElement = 'TextElement';

export function isTextElement(item: unknown): item is TextElement {
    return reflection.isInstance(item, TextElement);
}

export interface PositionAlongEdge extends Position {
    readonly $container: Edge | EdgePart | Node | PositionIntersection | TextElement;
    readonly $type: 'PositionAlongEdge';
    pos: number
}

export const PositionAlongEdge = 'PositionAlongEdge';

export function isPositionAlongEdge(item: unknown): item is PositionAlongEdge {
    return reflection.isInstance(item, PositionAlongEdge);
}

export interface PositionAnchor extends Position {
    readonly $container: Edge | EdgePart | Node | PositionIntersection | TextElement;
    readonly $type: 'PositionAnchor';
    node: Reference<Node>
    nodeanchor?: POS_ANCHOR
}

export const PositionAnchor = 'PositionAnchor';

export function isPositionAnchor(item: unknown): item is PositionAnchor {
    return reflection.isInstance(item, PositionAnchor);
}

export interface PositionIntersection extends Position {
    readonly $container: Edge | EdgePart | Node | PositionIntersection | TextElement;
    readonly $type: 'PositionIntersection';
    kind: INTERSECTION
    left: Position
    right: Position
}

export const PositionIntersection = 'PositionIntersection';

export function isPositionIntersection(item: unknown): item is PositionIntersection {
    return reflection.isInstance(item, PositionIntersection);
}

export interface PositionNormal extends Position {
    readonly $container: Edge | EdgePart | Node | PositionIntersection | TextElement;
    readonly $type: 'PositionNormal';
    posX: string
    posY: string
}

export const PositionNormal = 'PositionNormal';

export function isPositionNormal(item: unknown): item is PositionNormal {
    return reflection.isInstance(item, PositionNormal);
}

export interface PositionsInDiagramsAstType {
    Edge: Edge
    EdgePart: EdgePart
    Model: Model
    Node: Node
    Position: Position
    PositionAlongEdge: PositionAlongEdge
    PositionAnchor: PositionAnchor
    PositionIntersection: PositionIntersection
    PositionNormal: PositionNormal
    TextElement: TextElement
}

export class PositionsInDiagramsAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Edge', 'EdgePart', 'Model', 'Node', 'Position', 'PositionAlongEdge', 'PositionAnchor', 'PositionIntersection', 'PositionNormal', 'TextElement'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case PositionAlongEdge:
            case PositionAnchor:
            case PositionIntersection:
            case PositionNormal: {
                return this.isSubtype(Position, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'PositionAnchor:node': {
                return Node;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Edge': {
                return {
                    name: 'Edge',
                    mandatory: [
                        { name: 'parts', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'edges', type: 'array' },
                        { name: 'nodes', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new PositionsInDiagramsAstReflection();
